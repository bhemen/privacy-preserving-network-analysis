# EMP-toolkit

EMP-toolkit source is available [on github](https://github.com/emp-toolkit).


## Docker setup

The EMP-toolkit build files are no longer working, so the container we wrote for this project no longer produces a working installation. EMP-toolkit development is ongoing, so there is likely a working version if you can figure out the correct combination of dependency versions and EMP-toolkit software versions. When it did work, you could use the following process:

Create a Docker image. This will take a few minutes. You only have to do this
once.
```
$ docker build -t emp .
```
Spin up a Docker container from the image. 
```
$ docker run -it --rm emp
```
When the container builds successfully, it automatically builds all the examples and runs the benchmarking scripts.

## Visualize benchmarks
We saved benchmark results from the previously working system. The data lives in `benchmarks`. There's a directory for each of the two algorithms we tested -- Eisenburg and Noe (EN) and Elliot, Golub, and Jackson (EGJ). These data were generated by running `benchmark.sh` with a successful installation of the software.
However, it looks like the EN data was from a failed run, because some of the output files show a failure message and none of them take more than a second to run.

`visualize_benchmarks.py` is the program used to generate Figures ?? and ?? in the text. It parses the output of the `time` command used to benchmark each party, determines the maximum amount of RAM and time required across all parties to run the computation, and plots them. The output is in `emp-time.png` and `emp-ram.png`.


## Binaries and scripts
EMP-toolkit is a fairly complex piece of software. There are two ways to run a computation. To run in the semi-honest model, you implement your computation using the EMP-toolkit types, compile it into a binary, and run the binary for each party (with a bunch of configuration parameters so the separate processes can find each other). To run it in the malicious threat model, you compile the computation into a _circuit_, then write another piece of software that sets up the malicious computation with the circuit and calls all the appropriate set-up functions before executing the computation. You compile this code into a binary and run it for each party (again, with a bunch of config). To try and ease the burden of keeping all these steps in order, we have some utility scripts.

I don't see any `Makefiles`, which are used for the compilation steps (computation -> circuit, computation -> binary, and malicious engine + circuit -> binary), so those must have somehow been lost, but here's a description of the three primary software components we produced.

The primary computation is the EN and EGJ implementations. These are both written to take a command-line argument to determine whether to run in the semi-honest model or compile into a circuit. The computation is contained within `EN.cpp`, `EGJ.cpp`, `matrix.h`, and `fixedp.h` files. The last one is a custom implementation of fixed-point numbers built up from EMP-toolkit's `Integer` class. There are a few tests of the matrix utilities in `matmul_tests.cpp` and `matrix_tests.cpp`. 

Utility scripts here include `EGJ_circuit_sizes.sh` and `EN_circuit_sizes.sh`, which parse circuits and count the number of gates of each type. These were used to create Figure ??.

To benchmark in the malicious threat model, the `bench_mpc.cpp` software sets up the malicious computation with the EGJ circuit (as well as some other miscellaneous examples provided by EMP-toolkit).
- The `benchEGJ.sh` utility script compiles the EGJ circuit, copies it to the correct directory, compiles the benchmarking code, and runs it with a custom number of parties.
The `vbenchEGJ.sh` does the same thing, but runs the last party with the `valgrind` debugger.
- The `bench3.sh` and `bench9.sh` utility scripts compile and run the `bench_mpc.cpp` software for 3 and 9 parties, respectively.
The `vbench9.sh` script does the same thing, but runs the `valgrind` debugger on the 9th party. 

`cmpc_config.h` seems like a utility function to configure EMP-toolkit to run locally, but I can't tell what binaries actually compile with it.

Finally, there are a few other versions of the Eisenburg-Noe algorithm.
- `compare_clearing.py`: This is Python2, so you might have trouble running it, but I think it just runs the computation in the clear.
- `intclearing.cpp`: This runs a version of the EN algorithm implemented with integers rather than floating point numbers. 
- `runtest.sh`: Utility script that generates synthetic data (via `geninput.py`) and runs the `clearing` binary.

## Running examples

As mentioned, there are currently no Makefiles for our software and we have been unable to build EMP-toolkit in general. 
In general, if anything still worked, you could run examples in the 2-party, semi-honest model using the following process.

Generate synthetic data:
```
$ python geninput.py -n 2
```
Compile the semi-honest version of Eisenburg-Noe into an executable called `clearing`.
```
$ ???
```

Then run each party. The executables probably take three arguments and must be run from the `build` directory.
```
$ ./bin/<ex> <party> <port> <bitsize>
```
You can open two terminals and run each party separately, or run them in the same command:
```
$ ./bin/clearing 1 12345 32 & ./bin/clearing 2 12345 32
```
This is roughly derived from the `runtest.sh` script.